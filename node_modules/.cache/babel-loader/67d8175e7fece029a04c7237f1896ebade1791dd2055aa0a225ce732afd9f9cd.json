{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad, canvasRenderingContext2DSettings) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (!textureUrl && !input) {\n      throw new Error('Either textureUrl or input must be provided');\n    }\n    const validUrl = textureUrl !== null && textureUrl !== void 0 ? textureUrl : input;\n    if (!validUrl) {\n      throw new Error('A valid texture URL must be provided');\n    }\n    new Promise(resolve => {\n      textureLoader.load(validUrl, resolve);\n    }).then(texture => {\n      parseSpriteData(null, texture);\n    });\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n\n      //scale ratio for stadalone sprite\n      spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d', canvasRenderingContext2DSettings);\n      if (!ctx) {\n        throw new Error('Failed to get 2d context');\n      }\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      let spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      spritesArr = calculateScaleRatio(spritesArr);\n      return spritesArr;\n    }\n  };\n\n  // calculate scale ratio for the frames\n  const calculateScaleRatio = frames => {\n    // Find the largest frame\n    let largestFrame = null;\n    for (const frame of frames) {\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (!largestFrame || area > largestFrame.area) {\n        largestFrame = {\n          ...frame.frame,\n          area\n        };\n      }\n    }\n\n    // Set scaleRatio property on each frame\n    for (const frame of frames) {\n      var _largestFrame;\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (area === ((_largestFrame = largestFrame) == null ? void 0 : _largestFrame.area)) {\n        frame.scaleRatio = 1;\n      } else {\n        var _largestFrame2;\n        frame.scaleRatio = Math.sqrt(area / ((_largestFrame2 = largestFrame) == null ? void 0 : _largestFrame2.area));\n      }\n    }\n    return frames;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };","map":{"version":3,"names":["THREE","TextureLoader","useThree","useLoader","React","useState","getFirstItem","param","Array","isArray","keys","Object","w","h","checkIfFrameIsEmpty","frameData","i","length","calculateAspectRatio","width","height","factor","v","adaptedHeight","aspect","adaptedWidth","scaleX","scaleY","currentMaxScale","finalMaxScaleW","Math","min","finalMaxScaleH","Vector3","useSpriteLoader","input","json","animationNames","numberOfFrames","onLoad","canvasRenderingContext2DSettings","state","viewport","spriteDataRef","useRef","totalFrames","aspectFactor","spriteData","setSpriteData","spriteTexture","setSpriteTexture","Texture","textureLoader","spriteObj","setSpriteObj","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","parseSpriteData","loadStandaloneSprite","clear","loadJsonAndTexture","textureUrl","jsonUrl","Error","validUrl","Promise","resolve","load","then","texture","callback","jsonPromise","fetch","response","texturePromise","all","_spriteTexture","image","current","rows","columns","frameWidth","frameHeight","emptyFrames","getRowsAndColumns","frames","meta","version","size","scale","row","col","isExcluded","some","coord","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","calculateScaleRatio","parseFrames","encoding","colorSpace","SRGBColorSpace","canvas","document","createElement","ctx","getContext","drawImage","cols","round","sqrt","frameIndex","getImageData","data","isEmpty","sprites","delimiters","value","sourceWidth","sourceHeight","toLowerCase","indexOf","innerKey","spritesArr","key","largestFrame","area","_largestFrame","scaleRatio","_largestFrame2","preload","url"],"sources":["/Users/leofang/Desktop/Hackthon/node_modules/@react-three/drei/core/useSpriteLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad, canvasRenderingContext2DSettings) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (!textureUrl && !input) {\n      throw new Error('Either textureUrl or input must be provided');\n    }\n    const validUrl = textureUrl !== null && textureUrl !== void 0 ? textureUrl : input;\n    if (!validUrl) {\n      throw new Error('A valid texture URL must be provided');\n    }\n    new Promise(resolve => {\n      textureLoader.load(validUrl, resolve);\n    }).then(texture => {\n      parseSpriteData(null, texture);\n    });\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n\n      //scale ratio for stadalone sprite\n      spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d', canvasRenderingContext2DSettings);\n      if (!ctx) {\n        throw new Error('Failed to get 2d context');\n      }\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      let spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      spritesArr = calculateScaleRatio(spritesArr);\n      return spritesArr;\n    }\n  };\n\n  // calculate scale ratio for the frames\n  const calculateScaleRatio = frames => {\n    // Find the largest frame\n    let largestFrame = null;\n    for (const frame of frames) {\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (!largestFrame || area > largestFrame.area) {\n        largestFrame = {\n          ...frame.frame,\n          area\n        };\n      }\n    }\n\n    // Set scaleRatio property on each frame\n    for (const frame of frames) {\n      var _largestFrame;\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (area === ((_largestFrame = largestFrame) == null ? void 0 : _largestFrame.area)) {\n        frame.scaleRatio = 1;\n      } else {\n        var _largestFrame2;\n        frame.scaleRatio = Math.sqrt(area / ((_largestFrame2 = largestFrame) == null ? void 0 : _largestFrame2.area));\n      }\n    }\n    return frames;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}