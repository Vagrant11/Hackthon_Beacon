{"ast":null,"code":"import { Ray, Matrix4, Mesh, Vector3, Sphere, REVISION } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport * as THREE from 'three';\nconst BatchedMesh = THREE.BatchedMesh || null; // this is necessary to not break three.js r157-\nconst IS_REVISION_166 = parseInt(REVISION) >= 166;\nconst ray = /* @__PURE__ */new Ray();\nconst direction = /* @__PURE__ */new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst origBatchedRaycastFunc = BatchedMesh !== null ? BatchedMesh.prototype.raycast : null;\nconst _worldScale = /* @__PURE__ */new Vector3();\nconst _mesh = /* @__PURE__ */new Mesh();\nconst _batchIntersects = [];\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.isBatchedMesh) {\n    acceleratedBatchedMeshRaycast.call(this, raycaster, intersects);\n  } else {\n    acceleratedMeshRaycast.call(this, raycaster, intersects);\n  }\n}\nfunction acceleratedBatchedMeshRaycast(raycaster, intersects) {\n  if (this.boundsTrees) {\n    const boundsTrees = this.boundsTrees;\n    const drawInfo = this._drawInfo;\n    const drawRanges = this._drawRanges;\n    const matrixWorld = this.matrixWorld;\n    _mesh.material = this.material;\n    _mesh.geometry = this.geometry;\n    const oldBoundsTree = _mesh.geometry.boundsTree;\n    const oldDrawRange = _mesh.geometry.drawRange;\n    if (_mesh.geometry.boundingSphere === null) {\n      _mesh.geometry.boundingSphere = new Sphere();\n    }\n\n    // TODO: provide new method to get instances count instead of 'drawInfo.length'\n    for (let i = 0, l = drawInfo.length; i < l; i++) {\n      if (!this.getVisibleAt(i)) {\n        continue;\n      }\n\n      // TODO: use getGeometryIndex\n      const geometryId = drawInfo[i].geometryIndex;\n      _mesh.geometry.boundsTree = boundsTrees[geometryId];\n      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);\n      if (!_mesh.geometry.boundsTree) {\n        this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);\n        this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);\n        const drawRange = drawRanges[geometryId];\n        _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);\n      }\n      _mesh.raycast(raycaster, _batchIntersects);\n      for (let j = 0, l = _batchIntersects.length; j < l; j++) {\n        const intersect = _batchIntersects[j];\n        intersect.object = this;\n        intersect.batchId = i;\n        intersects.push(intersect);\n      }\n      _batchIntersects.length = 0;\n    }\n    _mesh.geometry.boundsTree = oldBoundsTree;\n    _mesh.geometry.drawRange = oldDrawRange;\n    _mesh.material = null;\n    _mesh.geometry = null;\n  } else {\n    origBatchedRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nfunction acceleratedMeshRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n    direction.copy(ray.direction).multiply(_worldScale);\n    const scaleFactor = direction.length();\n    const near = raycaster.near / scaleFactor;\n    const far = raycaster.far / scaleFactor;\n    const bvh = this.geometry.boundsTree;\n    if (raycaster.firstHitOnly === true) {\n      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material, near, far), this, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      const hits = bvh.raycast(ray, this.material, near, far);\n      for (let i = 0, l = hits.length; i < l; i++) {\n        const hit = convertRaycastIntersect(hits[i], this, raycaster);\n        if (hit) {\n          intersects.push(hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options = {}) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}\nexport function computeBatchedBoundsTree(index = -1, options = {}) {\n  if (!IS_REVISION_166) {\n    throw new Error('BatchedMesh: Three r166+ is required to compute bounds trees.');\n  }\n  if (options.indirect) {\n    console.warn('\"Indirect\" is set to false because it is not supported for BatchedMesh.');\n  }\n  options = {\n    ...options,\n    indirect: false,\n    range: null\n  };\n  const drawRanges = this._drawRanges;\n  const geometryCount = this._geometryCount;\n  if (!this.boundsTrees) {\n    this.boundsTrees = new Array(geometryCount).fill(null);\n  }\n  const boundsTrees = this.boundsTrees;\n  while (boundsTrees.length < geometryCount) {\n    boundsTrees.push(null);\n  }\n  if (index < 0) {\n    for (let i = 0; i < geometryCount; i++) {\n      options.range = drawRanges[i];\n      boundsTrees[i] = new MeshBVH(this.geometry, options);\n    }\n    return boundsTrees;\n  } else {\n    if (index < drawRanges.length) {\n      options.range = drawRanges[index];\n      boundsTrees[index] = new MeshBVH(this.geometry, options);\n    }\n    return boundsTrees[index] || null;\n  }\n}\nexport function disposeBatchedBoundsTree(index = -1) {\n  if (index < 0) {\n    this.boundsTrees.fill(null);\n  } else {\n    if (index < this.boundsTree.length) {\n      this.boundsTrees[index] = null;\n    }\n  }\n}","map":{"version":3,"names":["Ray","Matrix4","Mesh","Vector3","Sphere","REVISION","convertRaycastIntersect","MeshBVH","THREE","BatchedMesh","IS_REVISION_166","parseInt","ray","direction","tmpInverseMatrix","origMeshRaycastFunc","prototype","raycast","origBatchedRaycastFunc","_worldScale","_mesh","_batchIntersects","acceleratedRaycast","raycaster","intersects","isBatchedMesh","acceleratedBatchedMeshRaycast","call","acceleratedMeshRaycast","boundsTrees","drawInfo","_drawInfo","drawRanges","_drawRanges","matrixWorld","material","geometry","oldBoundsTree","boundsTree","oldDrawRange","drawRange","boundingSphere","i","l","length","getVisibleAt","geometryId","geometryIndex","getMatrixAt","premultiply","getBoundingBoxAt","boundingBox","getBoundingSphereAt","setDrawRange","start","count","j","intersect","object","batchId","push","undefined","copy","invert","applyMatrix4","setFromMatrixScale","multiply","scaleFactor","near","far","bvh","firstHitOnly","hit","raycastFirst","hits","computeBoundsTree","options","disposeBoundsTree","computeBatchedBoundsTree","index","Error","indirect","console","warn","range","geometryCount","_geometryCount","Array","fill","disposeBatchedBoundsTree"],"sources":["/Users/leofang/Desktop/Hackthon/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js"],"sourcesContent":["import { Ray, Matrix4, Mesh, Vector3, Sphere, REVISION } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport * as THREE from 'three';\n\nconst BatchedMesh = THREE.BatchedMesh || null; // this is necessary to not break three.js r157-\nconst IS_REVISION_166 = parseInt( REVISION ) >= 166;\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst origBatchedRaycastFunc = BatchedMesh !== null ? BatchedMesh.prototype.raycast : null;\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _mesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.isBatchedMesh ) {\n\n\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t} else {\n\n\t\tacceleratedMeshRaycast.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.boundsTrees ) {\n\n\t\tconst boundsTrees = this.boundsTrees;\n\t\tconst drawInfo = this._drawInfo;\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry = this.geometry;\n\n\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// TODO: use getGeometryIndex\n\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t}\n\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t_mesh.material = null;\n\t\t_mesh.geometry = null;\n\n\t} else {\n\n\t\torigBatchedRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options = {} ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\nexport function computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\tif ( ! IS_REVISION_166 ) {\n\n\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t}\n\n\tif ( options.indirect ) {\n\n\t\tconsole.warn( '\"Indirect\" is set to false because it is not supported for BatchedMesh.' );\n\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tindirect: false,\n\t\trange: null\n\t};\n\n\tconst drawRanges = this._drawRanges;\n\tconst geometryCount = this._geometryCount;\n\tif ( ! this.boundsTrees ) {\n\n\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t}\n\n\tconst boundsTrees = this.boundsTrees;\n\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\tboundsTrees.push( null );\n\n\t}\n\n\tif ( index < 0 ) {\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\toptions.range = drawRanges[ i ];\n\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees;\n\n\t} else {\n\n\t\tif ( index < drawRanges.length ) {\n\n\t\t\toptions.range = drawRanges[ index ];\n\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees[ index ] || null;\n\n\t}\n\n}\n\nexport function disposeBatchedBoundsTree( index = - 1 ) {\n\n\tif ( index < 0 ) {\n\n\t\tthis.boundsTrees.fill( null );\n\n\t} else {\n\n\t\tif ( index < this.boundsTree.length ) {\n\n\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t}\n\n\t}\n\n}\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,OAAO,EAAEC,IAAI,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACrE,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,OAAO,KAAKC,KAAK,MAAM,OAAO;AAE9B,MAAMC,WAAW,GAAGD,KAAK,CAACC,WAAW,IAAI,IAAI,CAAC,CAAC;AAC/C,MAAMC,eAAe,GAAGC,QAAQ,CAAEN,QAAS,CAAC,IAAI,GAAG;AACnD,MAAMO,GAAG,GAAG,eAAgB,IAAIZ,GAAG,CAAC,CAAC;AACrC,MAAMa,SAAS,GAAG,eAAgB,IAAIV,OAAO,CAAC,CAAC;AAC/C,MAAMW,gBAAgB,GAAG,eAAgB,IAAIb,OAAO,CAAC,CAAC;AACtD,MAAMc,mBAAmB,GAAGb,IAAI,CAACc,SAAS,CAACC,OAAO;AAClD,MAAMC,sBAAsB,GAAGT,WAAW,KAAK,IAAI,GAAGA,WAAW,CAACO,SAAS,CAACC,OAAO,GAAG,IAAI;AAC1F,MAAME,WAAW,GAAG,eAAgB,IAAIhB,OAAO,CAAC,CAAC;AACjD,MAAMiB,KAAK,GAAG,eAAgB,IAAIlB,IAAI,CAAC,CAAC;AACxC,MAAMmB,gBAAgB,GAAG,EAAE;AAE3B,OAAO,SAASC,kBAAkBA,CAAEC,SAAS,EAAEC,UAAU,EAAG;EAE3D,IAAK,IAAI,CAACC,aAAa,EAAG;IAEzBC,6BAA6B,CAACC,IAAI,CAAE,IAAI,EAAEJ,SAAS,EAAEC,UAAW,CAAC;EAElE,CAAC,MAAM;IAENI,sBAAsB,CAACD,IAAI,CAAE,IAAI,EAAEJ,SAAS,EAAEC,UAAW,CAAC;EAE3D;AAED;AAEA,SAASE,6BAA6BA,CAAEH,SAAS,EAAEC,UAAU,EAAG;EAE/D,IAAK,IAAI,CAACK,WAAW,EAAG;IAEvB,MAAMA,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMC,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,MAAMC,UAAU,GAAG,IAAI,CAACC,WAAW;IACnC,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpCd,KAAK,CAACe,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9Bf,KAAK,CAACgB,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAE9B,MAAMC,aAAa,GAAGjB,KAAK,CAACgB,QAAQ,CAACE,UAAU;IAC/C,MAAMC,YAAY,GAAGnB,KAAK,CAACgB,QAAQ,CAACI,SAAS;IAE7C,IAAKpB,KAAK,CAACgB,QAAQ,CAACK,cAAc,KAAK,IAAI,EAAG;MAE7CrB,KAAK,CAACgB,QAAQ,CAACK,cAAc,GAAG,IAAIrC,MAAM,CAAC,CAAC;IAE7C;;IAEA;IACA,KAAM,IAAIsC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGb,QAAQ,CAACc,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;MAEnD,IAAK,CAAE,IAAI,CAACG,YAAY,CAAEH,CAAE,CAAC,EAAG;QAE/B;MAED;;MAEA;MACA,MAAMI,UAAU,GAAGhB,QAAQ,CAAEY,CAAC,CAAE,CAACK,aAAa;MAE9C3B,KAAK,CAACgB,QAAQ,CAACE,UAAU,GAAGT,WAAW,CAAEiB,UAAU,CAAE;MAErD,IAAI,CAACE,WAAW,CAAEN,CAAC,EAAEtB,KAAK,CAACc,WAAY,CAAC,CAACe,WAAW,CAAEf,WAAY,CAAC;MAEnE,IAAK,CAAEd,KAAK,CAACgB,QAAQ,CAACE,UAAU,EAAG;QAElC,IAAI,CAACY,gBAAgB,CAAEJ,UAAU,EAAE1B,KAAK,CAACgB,QAAQ,CAACe,WAAY,CAAC;QAC/D,IAAI,CAACC,mBAAmB,CAAEN,UAAU,EAAE1B,KAAK,CAACgB,QAAQ,CAACK,cAAe,CAAC;QAErE,MAAMD,SAAS,GAAGR,UAAU,CAAEc,UAAU,CAAE;QAC1C1B,KAAK,CAACgB,QAAQ,CAACiB,YAAY,CAAEb,SAAS,CAACc,KAAK,EAAEd,SAAS,CAACe,KAAM,CAAC;MAEhE;MAEAnC,KAAK,CAACH,OAAO,CAAEM,SAAS,EAAEF,gBAAiB,CAAC;MAE5C,KAAM,IAAImC,CAAC,GAAG,CAAC,EAAEb,CAAC,GAAGtB,gBAAgB,CAACuB,MAAM,EAAEY,CAAC,GAAGb,CAAC,EAAEa,CAAC,EAAG,EAAG;QAE3D,MAAMC,SAAS,GAAGpC,gBAAgB,CAAEmC,CAAC,CAAE;QACvCC,SAAS,CAACC,MAAM,GAAG,IAAI;QACvBD,SAAS,CAACE,OAAO,GAAGjB,CAAC;QACrBlB,UAAU,CAACoC,IAAI,CAAEH,SAAU,CAAC;MAE7B;MAEApC,gBAAgB,CAACuB,MAAM,GAAG,CAAC;IAE5B;IAEAxB,KAAK,CAACgB,QAAQ,CAACE,UAAU,GAAGD,aAAa;IACzCjB,KAAK,CAACgB,QAAQ,CAACI,SAAS,GAAGD,YAAY;IACvCnB,KAAK,CAACe,QAAQ,GAAG,IAAI;IACrBf,KAAK,CAACgB,QAAQ,GAAG,IAAI;EAEtB,CAAC,MAAM;IAENlB,sBAAsB,CAACS,IAAI,CAAE,IAAI,EAAEJ,SAAS,EAAEC,UAAW,CAAC;EAE3D;AAED;AAEA,SAASI,sBAAsBA,CAAEL,SAAS,EAAEC,UAAU,EAAG;EAExD,IAAK,IAAI,CAACY,QAAQ,CAACE,UAAU,EAAG;IAE/B,IAAK,IAAI,CAACH,QAAQ,KAAK0B,SAAS,EAAG;IAEnC/C,gBAAgB,CAACgD,IAAI,CAAE,IAAI,CAAC5B,WAAY,CAAC,CAAC6B,MAAM,CAAC,CAAC;IAClDnD,GAAG,CAACkD,IAAI,CAAEvC,SAAS,CAACX,GAAI,CAAC,CAACoD,YAAY,CAAElD,gBAAiB,CAAC;IAE1DK,WAAW,CAAC8C,kBAAkB,CAAE,IAAI,CAAC/B,WAAY,CAAC;IAClDrB,SAAS,CAACiD,IAAI,CAAElD,GAAG,CAACC,SAAU,CAAC,CAACqD,QAAQ,CAAE/C,WAAY,CAAC;IAEvD,MAAMgD,WAAW,GAAGtD,SAAS,CAAC+B,MAAM,CAAC,CAAC;IACtC,MAAMwB,IAAI,GAAG7C,SAAS,CAAC6C,IAAI,GAAGD,WAAW;IACzC,MAAME,GAAG,GAAG9C,SAAS,CAAC8C,GAAG,GAAGF,WAAW;IAEvC,MAAMG,GAAG,GAAG,IAAI,CAAClC,QAAQ,CAACE,UAAU;IACpC,IAAKf,SAAS,CAACgD,YAAY,KAAK,IAAI,EAAG;MAEtC,MAAMC,GAAG,GAAGlE,uBAAuB,CAAEgE,GAAG,CAACG,YAAY,CAAE7D,GAAG,EAAE,IAAI,CAACuB,QAAQ,EAAEiC,IAAI,EAAEC,GAAI,CAAC,EAAE,IAAI,EAAE9C,SAAU,CAAC;MACzG,IAAKiD,GAAG,EAAG;QAEVhD,UAAU,CAACoC,IAAI,CAAEY,GAAI,CAAC;MAEvB;IAED,CAAC,MAAM;MAEN,MAAME,IAAI,GAAGJ,GAAG,CAACrD,OAAO,CAAEL,GAAG,EAAE,IAAI,CAACuB,QAAQ,EAAEiC,IAAI,EAAEC,GAAI,CAAC;MACzD,KAAM,IAAI3B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG+B,IAAI,CAAC9B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAG,EAAG;QAE/C,MAAM8B,GAAG,GAAGlE,uBAAuB,CAAEoE,IAAI,CAAEhC,CAAC,CAAE,EAAE,IAAI,EAAEnB,SAAU,CAAC;QACjE,IAAKiD,GAAG,EAAG;UAEVhD,UAAU,CAACoC,IAAI,CAAEY,GAAI,CAAC;QAEvB;MAED;IAED;EAED,CAAC,MAAM;IAENzD,mBAAmB,CAACY,IAAI,CAAE,IAAI,EAAEJ,SAAS,EAAEC,UAAW,CAAC;EAExD;AAED;AAEA,OAAO,SAASmD,iBAAiBA,CAAEC,OAAO,GAAG,CAAC,CAAC,EAAG;EAEjD,IAAI,CAACtC,UAAU,GAAG,IAAI/B,OAAO,CAAE,IAAI,EAAEqE,OAAQ,CAAC;EAC9C,OAAO,IAAI,CAACtC,UAAU;AAEvB;AAEA,OAAO,SAASuC,iBAAiBA,CAAA,EAAG;EAEnC,IAAI,CAACvC,UAAU,GAAG,IAAI;AAEvB;AAEA,OAAO,SAASwC,wBAAwBA,CAAEC,KAAK,GAAG,CAAE,CAAC,EAAEH,OAAO,GAAG,CAAC,CAAC,EAAG;EAErE,IAAK,CAAElE,eAAe,EAAG;IAExB,MAAM,IAAIsE,KAAK,CAAE,+DAAgE,CAAC;EAEnF;EAEA,IAAKJ,OAAO,CAACK,QAAQ,EAAG;IAEvBC,OAAO,CAACC,IAAI,CAAE,yEAA0E,CAAC;EAE1F;EAEAP,OAAO,GAAG;IACT,GAAGA,OAAO;IACVK,QAAQ,EAAE,KAAK;IACfG,KAAK,EAAE;EACR,CAAC;EAED,MAAMpD,UAAU,GAAG,IAAI,CAACC,WAAW;EACnC,MAAMoD,aAAa,GAAG,IAAI,CAACC,cAAc;EACzC,IAAK,CAAE,IAAI,CAACzD,WAAW,EAAG;IAEzB,IAAI,CAACA,WAAW,GAAG,IAAI0D,KAAK,CAAEF,aAAc,CAAC,CAACG,IAAI,CAAE,IAAK,CAAC;EAE3D;EAEA,MAAM3D,WAAW,GAAG,IAAI,CAACA,WAAW;EACpC,OAAQA,WAAW,CAACe,MAAM,GAAGyC,aAAa,EAAG;IAE5CxD,WAAW,CAAC+B,IAAI,CAAE,IAAK,CAAC;EAEzB;EAEA,IAAKmB,KAAK,GAAG,CAAC,EAAG;IAEhB,KAAM,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2C,aAAa,EAAE3C,CAAC,EAAG,EAAG;MAE1CkC,OAAO,CAACQ,KAAK,GAAGpD,UAAU,CAAEU,CAAC,CAAE;MAC/Bb,WAAW,CAAEa,CAAC,CAAE,GAAG,IAAInC,OAAO,CAAE,IAAI,CAAC6B,QAAQ,EAAEwC,OAAQ,CAAC;IAEzD;IAEA,OAAO/C,WAAW;EAEnB,CAAC,MAAM;IAEN,IAAKkD,KAAK,GAAG/C,UAAU,CAACY,MAAM,EAAG;MAEhCgC,OAAO,CAACQ,KAAK,GAAGpD,UAAU,CAAE+C,KAAK,CAAE;MACnClD,WAAW,CAAEkD,KAAK,CAAE,GAAG,IAAIxE,OAAO,CAAE,IAAI,CAAC6B,QAAQ,EAAEwC,OAAQ,CAAC;IAE7D;IAEA,OAAO/C,WAAW,CAAEkD,KAAK,CAAE,IAAI,IAAI;EAEpC;AAED;AAEA,OAAO,SAASU,wBAAwBA,CAAEV,KAAK,GAAG,CAAE,CAAC,EAAG;EAEvD,IAAKA,KAAK,GAAG,CAAC,EAAG;IAEhB,IAAI,CAAClD,WAAW,CAAC2D,IAAI,CAAE,IAAK,CAAC;EAE9B,CAAC,MAAM;IAEN,IAAKT,KAAK,GAAG,IAAI,CAACzC,UAAU,CAACM,MAAM,EAAG;MAErC,IAAI,CAACf,WAAW,CAAEkD,KAAK,CAAE,GAAG,IAAI;IAEjC;EAED;AAED","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}